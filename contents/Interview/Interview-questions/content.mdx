---
slug: Interview-questions
title: 면접 질문 - js
description : 자바스크립트 면접 질문 정리
date: 2024-07-01
tags: ['Interview']
thumbnail: /assets/contents/Interview/Interview-questions/cover.png
published: true
---

[면접 질문 참고 Link](https://velog.io/@qnrjs42/23.10-24.01-3%EB%85%84%EC%B0%A8-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EB%95%8C-%EB%B0%9B%EC%95%98%EB%8D%98-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8A%90%EB%82%80-%EC%A0%90-react#1-%EC%9E%90%EA%B8%B0%EC%86%8C%EA%B0%9C%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

## **Javascript**

## 1. 이벤트 루프 설명해주세요

```js showLineNumbers
console.log('Start'); // 1 ) Start

setTimeout(() => { // 2 ) setTimeout
  console.log('Timeout');
}, 3000);

console.log('End');
```
* 콜 스택 (호출스택) 
* 콜백 큐 (메시지 큐)
* 이벤트 루프
* 웹 API

위의 코드를 실행하면 다음과 같은 순서로 실행됩니다.

1. `콜스택`으로 console.log('Start') 함수가 들어와 실행하여 즉시 출력후 `콜스택`을 비워줍니다.
2. 그 다음으로 setTimeout 함수가 콜스택으로 호출됩니다. `웹 API`가 3초를 기다린후,`콜백 큐`로 보냅니다. 
3. `콜스택`에 console.log('End') 함수가 호출되어 즉시 출력후 `콜스택`을 비워줍니다. 
4.  `콜백 큐`에 있는 setTimeout 콜백이 `콜스택`으로 이동시켜 실행하여 'Timeout'을 출력합니다. <br/>
    <small>(이벤트 루프는 계속 콜스택을 주시하고 있는데, 콜스택이 비어져있으면 콜백 큐에 있는 이벤트를 콜스택으로 보내줍니다.)</small>

<br/>

<Callout type="info">
 참고자료 )
   - [(JavaScript) Event loop와 call stack 은 어떻게 작동하나?](https://www.youtube.com/watch?v=zi-IG6VHBh8)
   - [(JavaScript) 이벤트루프에 대해 파헤쳐 봅시다](https://yong-nyong.tistory.com/71)
   - [(JavaScript) 자바스크립트 이벤트 루프 동작 구조 & 원리 끝판왕](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
</Callout>


## 2. 호이스팅 설명해주세요

호이스트란 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것을 의미합니다.

전역에서 선언된 변수는 전역 컨텍스트 촤상위로 끌어올려지며, 함수 내에 선언된 변수는 함수 최상위로 끌어올려집니다. 

그리고 모든 선언문(var, let, const, function, function*, class)은 호이스팅 됩니다.

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계와 초기화 단계가 한번에 진행됩니다.

let, const 키워드로 선언된 변수는 선언 단계가 이뤄지고 런타임 때 초기화와 할당이 이뤄집니다.

```js showLineNumbers
console.log(x); //  undefined
var x = 12;

console.log(x); //  12

{
  x = 1;
}
console.log(x); // 1
```

```js showLineNumbers
function test() {
	// const도 호이스팅이 되긴하지만 초기화를 하지 않는다.
	// 초기화가 되기 전에 참조하면 해당 참조 에러가 발생한다.
	console.log(x); // ReferenceError: Cannot access 'x' before initialization
	const x = 1;
}

test();
```


<Callout type="info">
**참고자료 )**

- [PoiemaWeb](https://poiemaweb.com/js-data-type-variable)
- [자바스크립트의 호이스팅(Hoisting)](https://poiemaweb.com/js-data-type-variable)
</Callout>

## 3. 프로토타입 설명해주세요

자바스크립트의 모든 객체는 부모 역할을 담당하는 객체와 연결 되어 있습니다.
부모 객체의 프로퍼티 또는 메서드를 상속받아 사용 할 수 있습니다.
이러한 부모 객체를 프로토타입이라고 합니다.

자신의 객체에 프로퍼티나 메서드에 접근하려고 할 때,
객체에 프로퍼티나 메서드가 없다면, 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색합니다.
이를 `프로토타입 체인`이라 합니다.

프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype입니다. <br/>
따라서 모든 객체는 Object.prototype을 상속받습니다. 
Object.prototype을 프토토타입 체인의 종점이라 합니다.


프로토타입 체인의 종점에도 프로퍼티나 메서드를 검색할 수 없는 경우 undefined를 반환합니다. <br/>
자바스크립트는 클래스 대신 기존의 개체를 복사하여 새로운 객체를 생성하는 것을 프로토타입 방식이라 합니다. <br/>
프로토타입은 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용합니다. <br/>
프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있습니다.

```js showLineNumbers
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function() {
  return this.name;
};

const me = new Person('Lee');

console.log(me.getName()); // Lee
```


<Callout type="info">
  **참고자료 )**
  
  [프로토 타입 객체](https://poiemaweb.com/js-prototype)
</Callout>

## 4. 클로저 설명해주세요

클로저는 자신이 생성될 때 상위 스코프 렉시컬 환경을 기억하고 있어, 
외부 함수의 실행이 끝나서 실행 컨텍스트에서 소멸된 이후에도 외부함수의 렉시컬 환경을 내부함수가 참조하고 있기 때문에 내부함수가 외부함수 변수에 접근이 가능합니다.

내부함수가 참조하지 않은 외부함수의 변수는 가비지 컬렉터에 등록됩니다.

자바스크립트는 자신을 누군가 참조하고 있다면 가비지 컬렉터에 등록되지 않습니다.

**주로 react에서 사용하는 방식입니다.**

```js showLineNumbers
function counter(start) {
  let count = start; // 외부 환경의 변수

  return function() {
    count++; // 외부 환경의 변수를 참조하고 변경
    return count;
  };
}

const counterFunc = counter(0);

console.log(counterFunc()); // 1
console.log(counterFunc()); // 2
console.log(counterFunc()); // 3

```


### 장점
- 전역 변수를 줄일 수 있습니다.
- 코드 재사용률을 높일 수 있습니다.

### 단점
- 메모리에 계속 남아있어 직접 메모리를 해제해야 합니다.

<Callout type="info">
  **참고자료 )**
  
  [클로저의 개념](https://poiemaweb.com/js-closure)
</Callout>

## 5. 스코프 설명해주세요

스코프는 유효 범위를 뜻하며,
모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)가 
자신이 선언된 위치에 의해, 다른 코드가 식별자를 참조할 수 있는 유효 범위가 결정되는 것입니다.

<Callout>
  **스코프 유효 범위는 크게 전역 스코프와 지역 스코프로 나뉩니다.**
  
  - 전역 스코프 : 코드의 가장 바깥 영역을 말하며, 전역 스코프를 만듭니다.
  - 지역 스코프 : 함수 몸체 내부를 말하며, 지역 스코프를 만듭니다.
</Callout>

스코프가 계층적으로 연결된 것을 `스코프 체인`이라 합니다.

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만,
하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없습니다. 
**즉, 하위 스코프 기준으로 위로는 검색하지만 아래로는 검색하지 않습니다.**

{/* /console.log/ caption="Im a caption" */}
```js showLineNumbers {5,9} title="예시" 
let x = 'global';

function foo() {
  let x = 'local';
  console.log(x); // local
}

foo();
console.log(x); // global
```

좀 더 자세히 설명하면,

모든 코드 블록(if, for, while, try/catch 등)은 지역 스코프를 만들고 이러한 특성을 `블록 레벨 스코프`라 합니다.

var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하기 때문에 이러한 특성을 `함수 레벨 스코프`라 합니다.

자바스크립트는 `렉시컬 스코프`를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정합니다.

<Callout type="info">
**참고자료 )**

[스코프란](https://poiemaweb.com/js-scope)
</Callout>


## 6. 데이터 타입에는 무엇이 있나요?
 <Callout >
  **원시 타입** 
    * number
    * string
    * boolean
    * undefined
    * null
    * symbol
 </Callout>

<Callout>
  **객체 타입** 
    * object
    * function
    * array
</Callout>

## 7. const 키워드로 선언된 변수 중에서 string 타입을 가진 값은 재할당이 되지 않는데 array에서는 데이터 삽입, 수정, 삭제가 되는 이유는 무엇인가요?

원시 타입의 값은 변경 불가능한 값을 뜻하며,
객체(참조) 타입의 값은 변경 가능한 값을 뜻합니다.

상수(`const`)는 재할당이 금지된 변수를 말합니다.

**원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 
변수는 새롭게 재할당한 원시 값을 가리킵니다. 
이때 변수가 참조하던 메모리 공간의 주소가 변경됩니다. 
값의 이러한 특성을 불변성이라 합니다.**

<Callout>
  **결론 )**
  
  원시 타입을 가진 값은 재할당 시 새로운 값이 담겨있는 메모리 주소를 새롭게 참조합니다. 
  그래서 const는 재할당이 금지되어 있기 때문에 원시 타입을 가진 변수는 메모리 주소를 변경할 수 없습니다.
  <br/>
  
  const 키워드로 선언된 객체는 값을 가리키는 메모리 주소를 참조하고 있으며, 그 참조된 메모리 주소에는 값이 들어 있고, 객체는 변경 가능한 값이므로 메모리 주소를 변경하는게 아니라 값을 변경하기 때문에 객체나 배열에 삽입, 수정, 삭제를 할 수 있습니다.
  <br/>
  
  메모리 주소 변경이 재할당이라 생각하면 간단합니다. 즉 const는 재할당 불가 - 메모리 주소 변경 불가
</Callout>

<Callout type="info">
  **참고자료 )**
  
  - [데이터 타입과 변수](https://poiemaweb.com/js-data-type-variable)
  - [객체와 변경불가성(Immutability)](https://poiemaweb.com/js-immutability)
</Callout>

## 8. 비동기에 대해 아는대로 설명해주세요

비동기 프로그래밍은 여러 작업을 동시에 실행하고 끝날 때까지 기다리지 않고, 바로 다음 작업을 수행하는 방식을 뜻합니다.

즉, 하나의 작업을 시작한 후 그 작업이 끝나기를 기다리지 않고 다른 작업을 수행하며, 
나중에 첫 번째 작업의 결과를 처리하는 방법입니다. 

비동기 프로그래밍을 통해 동시에 여러 작업을 효율적으로 처리할 수 있습니다.

```js showLineNumbers /callback/ /userData/ title="콜백 함수 사용"
// 콜백 함수 사용
function loadUserData(callback) {
  setTimeout(() => {
    const userData = {
      name: "철수",
      age: 30
    };
    callback(userData);
  }, 1000);
}

loadUserData((userData) => {
  console.log(userData); // { name: "철수", age: 30 }
});
```

```js showLineNumbers /promise/ /resolve/ /reject/ title="프로미스 사용"
function loadUserData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const userData = {
        name: "영희",
        age: 25
      };
      resolve(userData);
    }, 2000);
  });
}

loadUserData().then((userData) => {
  console.log(userData); // { name: "영희", age: 25 }
});
```

<Callout type="warn">
  **for와 forEach() 차이는 동기와 비동기 입니다.**<br/>
**forEach()는 Promise를 기다리지 않기 때문에 async/await을 사용할 수 없으며, 대신 map()과 Promise.all()을 사용합니다.**
</Callout>

## 9. 프로미스에 대해 설명해주세요

> 프로미스는 콜백 지옥의 단점을 보완하며, 비동기 처리 시점을 명확하게 표현할 수 있습니다.

`resolve`와 `reject` 함수를 인자로 전달 받아서
비동기 처리가 성공하면 `resolve()`함수 호출하고,
비동기 처리가 실패하면 `reject()` 함수를 호출합니다.

처리 결과는 각 함수 인수에 전달하면서 호출합니다.

프로미스는 마이크로태스크 큐에 저장되며 태스크 큐보다 우선순위가 높습니다.


  <Callout title="프로미스 정적 메서드">

    `all`
    `race`
    `allSettled`
    `any`
    `resolve`
    `reject`
  </Callout>
  
  <Callout title="인스턴스 메서드">
     `catch`
     `then`
     `finally`
  </Callout>

<br/>

<Callout type="info">
  **참고자료 )**
  
  [프로미스](https://poiemaweb.com/es6-promise)
  
  Promise - JavaScript | MDN
</Callout>

## 10. 프로미스의 비동기 동작 원리에 대해 설명해주세요
JavaScript 프로그래밍에서 Promise는 비동기 작업을 효율적으로 처리하기 위한 강력한 메커니즘입니다. 
Promise는 비동기 작업의 성공 또는 실패를 나타내는 객체로, 이러한 작업이 완료될 미래의 어느 시점에 결과를 처리할 수 있도록 합니다. 

**Promise는 세 가지 상태를 가집니다: 대기(`pending`), 이행(`fulfilled`), 및 거부(`rejected`).**

대기 상태는 작업이 아직 완료되지 않았음을 나타내고, 이행 상태는 작업이 성공적으로 완료되어 결과 값을 반환했음을 의미하며, 
거부 상태는 작업이 실패했음을 나타냅니다.

Promise는 `then()`, `catch()`, 및 `finally()` 메서드를 통해 비동기 작업의 결과를 처리할 수 있습니다. 

`then()`은 작업이 성공적으로 완료되었을 때 호출되는 콜백 함수를 등록합니다. <br/>
`catch()`는 작업이 실패했을 때 호출되는 콜백 함수를 등록합니다. <br/>
`finally()`는 작업의 성공 여부에 관계없이 항상 실행되는 콜백 함수를 등록합니다.

```js showLineNumbers
function asyncTask() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      if (success) {
        resolve('작업이 성공적으로 완료되었습니다.');
      } else {
        reject('작업이 실패했습니다.');
      }
    }, 1000);
  });
}

asyncTask()
  .then(result => {
    console.log(result); // '작업이 성공적으로 완료되었습니다.'
  })
  .catch(error => {
    console.error(error); // '작업이 실패했습니다.'
  })
  .finally(() => {
    console.log('비동기 작업이 종료되었습니다.');
  });
```

asyncTask 함수는 1초 후에 성공 또는 실패를 무작위로 결정하는 비동기 작업을 시뮬레이트합니다. 

Promise는 비동기 작업의 완료를 기다리며, then(), catch(), 및 finally()를 통해 결과를 처리합니다.

Promise를 사용하면 콜백 지옥(callback hell)을 피하고, 코드의 가독성과 유지보수성을 크게 향상시킬 수 있습니다. 
특히 여러 비동기 작업을 순차적으로 또는 병렬로 처리할 때 유용합니다. 

`Promise.all()`, `Promise.race()`와 같은 메서드를 통해 여러 Promise를 조합하여 더욱 복잡한 비동기 로직을 효율적으로 처리할 수 있습니다.


<Callout>
  **참고자료 )**
  
  Graceful asynchronous programming with Promises - Web 개발 학습하기 | MDN
</Callout>

## 11. 함수형 프로그래밍에 대해 설명해주세요

함수가 일급 객체이기 때문에 함수형 프로그래밍 방식이 선호됩니다.

함수형 프로그래밍은 함수의 개념을 중심으로 하는 프로그래밍 패러다임으로, 주로 순수 함수와 불변 데이터를 강조합니다. 

함수들을 블록처럼 쌓아 로직을 구현하여, 코드의 가독성, 예측 가능성, 유지보수성, 재사용성을 높입니다.


### 순수 함수 (Pure Functions):

* 동일한 입력이 주어지면 항상 동일한 출력을 반환하는 함수입니다.
* 함수 내부에서 외부 상태를 변경하지 않으며, 부작용(side effects)이 없습니다

```js showLineNumbers
function add(a, b) {
  return a + b;
}
```

### 불변성 (Immutability):

* 데이터는 변경되지 않습니다. 상태를 변경하려면 새로운 데이터를 생성합니다.
* JavaScript에서 Object.freeze()나 스프레드 연산자 등을 사용하여 불변성을 유지할 수 있습니다.
  
  ```js showLineNumbers
  const originalArray = [1, 2, 3];
  const newArray = [...originalArray, 4]; // [1, 2, 3, 4];

  const obj = { x: 1, y: 2 };
  const frozenObj = Object.freeze(obj);
  frozenObj.z = 3; // TypeError: Cannot add property z, object is not extensible
  ```

### 고차 함수 (Higher-Order Functions):

* 함수를 매개변수로 전달받거나 함수를 반환하는 함수입니다.
* 대표적인 고차 함수로는 map(), filter(), reduce()가 있습니다

  
  ```js showLineNumbers
  const numbers = [1, 2, 3, 4, 5];
  const squared = numbers.map(n => n ** 2); // [1, 4, 9, 16, 25]
  ```

### 일급 객체 (First-Class Citizens):

* 함수가 다른 변수와 동일하게 취급됩니다. 즉, 함수를 변수에 할당하거나, 함수의 인자로 전달하거나, 함수에서 반환할 수 있습니다.

    
    ```js showLineNumbers
    const add = (a, b) => a + b;
    const subtract = (a, b) => a - b;
  
    const calculate = (fn, a, b) => fn(a, b);
    console.log(calculate(add, 1, 2)); // 3
    console.log(calculate(subtract, 3, 1)); // 2
    ```

### 재귀 (Recursion):

* 반복문 대신 함수가 자기 자신을 호출하여 반복 작업을 수행합니다.
* 꼬리 재귀(Tail Recursion)를 통해 최적화할 수 있습니다


```js showLineNumbers
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc);
}

console.log(factorial(5)); // 120
```

### 합성 (Composition):

* 함수를 조합하여 새로운 함수를 만드는 것을 뜻합니다.
* 함수형 프로그래밍에서는 작은 함수를 조합하여 복잡한 로직을 구현합니다.


```js showLineNumbers
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

const addAndMultiply = (a, b, c) => multiply(add(a, b), c);
console.log(addAndMultiply(1, 2, 3)); // 9
```

### 커링 (Currying):

* 여러 개의 인자를 받는 함수를 단일 인자를 받는 함수들로 변환하는 것을 뜻합니다.
* 함수형 프로그래밍에서는 커링을 통해 함수를 부분 적용하여 재사용성을 높입니다.


```js showLineNumbers
const add = a => b => a + b;
const add3 = add(3);
console.log(add3(2)); // 5
```

### 모나드 (Monad):

* 함수형 프로그래밍에서 부작용을 제어하기 위한 방법으로 사용됩니다.
* 모나드는 값을 감싸고 있는 컨테이너로, 값을 추출하거나 변환하는 함수를 제공합니다.


```js showLineNumbers
const Maybe = value => ({
  map: fn => value ? Maybe(fn(value)) : Maybe(null),
  value: () => value
});

const result = Maybe(10)
  .map(value => value * 2)
  .map(value => value + 1)
  .value();

console.log(result); // 21
```

### 함수형 프로그래밍의 장점
* 가독성 - 코드가 간결하고 직관적입니다. 각 함수는 하나의 작업만 수행하므로 이해하기 쉽습니다.
* 예측 가능성 - 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하므로, 디버깅과 테스트가 용이합니다.
* 병렬 처리 - 불변 데이터를 사용하므로, 병렬 처리가 안전하고 효율적입니다.
* 유지보수성 - 모듈화된 코드로 인해 유지보수가 쉽습니다. 각 함수는 독립적으로 테스트하고 수정할 수 있습니다.



<Callout type="info">
  **참고자료 )**
  
  [함수](https://poiemaweb.com/js-function)  
</Callout>
